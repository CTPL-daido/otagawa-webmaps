<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>スマホ最適・地理院タイル切替（地図右上レイヤ追従）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- Leaflet（CDN） -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Layers Tree（CDN） -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.control.layers.tree@2.0.2/L.Control.Layers.Tree.css" />
  <script src="https://unpkg.com/leaflet.control.layers.tree@2.0.2/L.Control.Layers.Tree.min.js"></script>

  <!-- Hash（CDN） -->
  <script src="https://unpkg.com/leaflet-hash@0.2.1/leaflet-hash.js"></script>

  <!-- MarkerCluster（CDN） -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    /* 画面いっぱいの地図。iOSの上下バーでも崩れにくく */
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    body { overscroll-behavior: none; touch-action: pan-x pan-y; }
    #map { padding-bottom: env(safe-area-inset-bottom); }

    /* レイヤーツリー：常に“地図の右上”に追従（Leaflet標準の absolute をそのまま使う） */
    .leaflet-top.leaflet-right { top: 10px; right: 10px; z-index: 1000; }
    .leaflet-control-layers {
      max-height: 60vh; overflow-y: auto; -webkit-overflow-scrolling: touch; font-size: 14px;
      background: rgba(255,255,255,.95);
    }
    .leaflet-control-layers-toggle { width: 36px; height: 36px; }

    /* ズームボタンをタップしやすく */
    .leaflet-control-zoom a { width: 40px; height: 40px; line-height: 40px; font-size: 20px; }

    /* 出典の視認性を少しだけ向上 */
    .leaflet-control-attribution { backdrop-filter: blur(2px); }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- qgis2web エクスポートのデータ（枠と点） -->
  <script src="data/_1.js"></script>       <!-- ポリゴン（枠）: json__1 -->
  <script src="data/gis_2.js"></script>    <!-- 点（URL付き）   : json_gis_2 -->

  <script>
    // ===== マップ初期化（“過ズーム白画面”の原因を排除） =====
    const map = L.map('map', {
      zoomControl: false,
      // ★ GSIタイルの上限に合わせてクランプ（pinchで18を超えない）
      maxZoom: 18,
      minZoom: 1,
      tap: true
      // zoomSnap/zoomDeltaは未指定：お手本に合わせ、Leaflet標準のピンチ挙動を使う
    }).fitBounds([[35.018, 136.883],[35.028, 136.900]]);
    new L.Hash(map);

    // 左上：ズーム（地図の左上に追従）
    L.control.zoom({ position: 'topleft' }).addTo(map);

    // 出典（お手本準拠）
    map.attributionControl.setPrefix(
      '<a href="https://github.com/tomchadwin/qgis2web" target="_blank" rel="noopener">qgis2web</a> · ' +
      '<a href="https://leafletjs.com" target="_blank" rel="noopener">Leaflet</a> · ' +
      '<a href="https://qgis.org" target="_blank" rel="noopener">QGIS</a>'
    );

    // ===== ベースマップ（GSI：上限は18。過ズームでタイル欠損しない） =====
    const gsiListUrl = 'https://maps.gsi.go.jp/development/ichiran.html';
    const basePale = L.tileLayer(
      'https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png',
      { minZoom: 1, maxZoom: 18,
        attribution: '出典：<a href="'+gsiListUrl+'" target="_blank" rel="noopener">地理院タイル</a>（淡色地図）' }
    ).addTo(map); // 初期：淡色
    const basePhoto = L.tileLayer(
      'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg',
      { minZoom: 1, maxZoom: 18,
        attribution: '出典：<a href="'+gsiListUrl+'" target="_blank" rel="noopener">地理院タイル</a>（全国最新写真）' }
    );

    // ===== オーバーレイ：枠 =====
    const layerPolygon = L.geoJSON(json__1, {
      interactive: true,
      style: () => ({ color: 'red', weight: 3, opacity: 1, fill: false }),
      onEachFeature: (f, layer) => {
        layer.bindPopup('<table><tr><td>fid:</td><td>' + (f.properties?.fid ?? '') + '</td></tr></table>');
      }
    }).addTo(map);

    // ===== オーバーレイ：点（ピンチでもサイズ変化なし＝固定半径） =====
    const layerPoints = L.geoJSON(json_gis_2, {
      interactive: true,
      pointToLayer: (f, latlng) => L.circleMarker(latlng, {
        radius: 6,              // ★ 固定半径。ズーム・タップでも変化しない
        fillColor: '#ffcc00',
        color: '#000',
        weight: 1, opacity: 1, fillOpacity: 1
      }),
      onEachFeature: (f, layer) => {
        const link = f.properties?.url || f.properties?.URL; // url/URL どちらでも
        let html = '<table><tr><td>fid:</td><td>' + (f.properties?.fid ?? '') + '</td></tr>';
        if (link) html += '<tr><td>URL:</td><td><a href="'+link+'" target="_blank" rel="noopener">リンク</a></td></tr>';
        html += '</table>';
        layer.bindPopup(html);
      }
    });

    // クラスタ（お手本準拠）
    const clusterPoints = L.markerClusterGroup({
      showCoverageOnHover: false,
      spiderfyOnMaxZoom: true,
      disableClusteringAtZoom: 17
    }).addLayer(layerPoints).addTo(map);

    // ===== レイヤーコントロール：常に“地図の右上”に追従 =====
    const baseTree = {
      label: '背景地図',
      children: [
        { label: '地理院タイル（淡色地図）', layer: basePale,  radioGroup: 'basemap' },
        { label: '地理院タイル（全国最新写真）', layer: basePhoto, radioGroup: 'basemap' }
      ]
    };
    const overlayTree = {
      label: '表示レイヤ',
      children: [
        { label: '枠（ポリゴン）', layer: layerPolygon },
        { label: 'gis点（クラスタ）', layer: clusterPoints }
      ]
    };
    L.control.layers.tree(baseTree, overlayTree, {
      collapsed: false,          // 初期から展開（見失わない）
      namedToggle: true,
      selectAllCheckbox: true,
      position: 'topright'       // ← 地図の右上。二本指ズームでも“地図と一緒に”動く
    }).addTo(map);

    // ===== 表示範囲（データに合わせる） =====
    const boundsGroup = L.featureGroup([layerPolygon, layerPoints]);
    if (boundsGroup.getLayers().length) {
      map.fitBounds(boundsGroup.getBounds(), { padding: [10, 10] });
    }

    // ===== 真っ白対策（エラー時の可視化） =====
    window.addEventListener('error', e => {
      const msg = document.createElement('div');
      msg.style.cssText='position:fixed;left:8px;bottom:8px;background:#000a;color:#fff;padding:6px 8px;border-radius:6px;font:12px/1.4 system-ui;z-index:9999';
      msg.textContent='Error: '+(e.message||'unknown');
      document.body.appendChild(msg); setTimeout(()=>msg.remove(),8000);
    });
  </script>
</body>
</html>