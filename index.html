<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>WEBマップ（自前レイヤーパネル・スマホ最適化）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- Leaflet（CDN） -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root { --vh: 1vh; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #fff;
    }

    /* 画面いっぱい（iPhoneのアドレスバー変動対応） */
    #map {
      width: 100%;
      height: calc(var(--vh) * 100);
      touch-action: pan-x pan-y pinch-zoom;
      overscroll-behavior: none;
    }

    /* レイヤーパネル */
    .layer-panel {
      position: absolute;
      top: calc(env(safe-area-inset-top) + 8px);
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(4px);
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
      padding: 10px 12px;
      font: 14px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif;
    }
    .layer-panel h3 { margin: 0 0 6px; font-size: 14px; }
    .layer-panel .sec { margin-top: 8px; }
    .layer-panel label { display: flex; align-items: center; gap: 6px; margin: 4px 0; }

    /* 出典 */
    .credit {
      position: absolute;
      right: 8px;
      bottom: calc(env(safe-area-inset-bottom) + 8px);
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      padding: 6px 8px;
      border-radius: 10px;
      font: 12px/1.3 system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif;
      box-shadow: 0 4px 12px rgba(0,0,0,0.12);
    }

    /* 枠レイヤーは常時ONでタップ透過 */
    .leaflet-pane.frame-pane { z-index: 550; pointer-events: none; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- レイヤーパネル -->
  <div class="layer-panel" id="layerPanel">
    <h3>レイヤ</h3>
    <div class="sec">
      <strong>ベース</strong>
      <div><label><input type="radio" name="base" value="gsi_pale" checked> 地理院タイル（淡色）</label></div>
      <div><label><input type="radio" name="base" value="gsi_std"> 地理院タイル（標準）</label></div>
      <div><label><input type="radio" name="base" value="osm"> OpenStreetMap</label></div>
    </div>
    <div class="sec">
      <strong>オーバーレイ</strong>
      <div><label><input type="checkbox" data-overlay="points" checked> 地点（タップ可）</label></div>
      <div><label><input type="checkbox" data-overlay="lines" checked> 線・範囲</label></div>
      <div><label><input type="checkbox" data-overlay="labels"> ラベル</label></div>
      <div><label><input type="checkbox" checked disabled> 枠（常時ON）</label></div>
    </div>
  </div>

  <!-- 出典 -->
  <div class="credit">
    出典：<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank" rel="noopener">国土地理院タイル</a>、© OpenStreetMap contributors
  </div>

  <script>
    // iPhone対応: 実際の画面高さに追従
    function setVh() {
      document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
    }
    setVh();
    window.addEventListener('resize', setVh);
    window.addEventListener('orientationchange', setVh);

    // --- 地図本体 ---
    const map = L.map('map', {
      zoomControl: true,
      attributionControl: true,
      tap: false,
      minZoom: 4, maxZoom: 19
    }).setView([35.004, 136.883], 15); // 中心とズーム調整

    map.attributionControl.setPrefix('');

    // --- ベース ---
    const gsi_pale = L.tileLayer(
      'https://tile-c.openstreetmap.jp/styles/gsi-pale/{z}/{x}/{y}.png',
      { maxZoom: 19, attribution: '国土地理院タイル（淡色）' }
    );

    const gsi_std = L.tileLayer(
      'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png',
      { maxZoom: 19, attribution: '国土地理院タイル（標準）' }
    );

    const osm = L.tileLayer(
      'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      { maxZoom: 19, attribution: '© OpenStreetMap contributors' }
    );

    const baseLayers = { gsi_pale, gsi_std, osm };
    gsi_pale.addTo(map);

    // --- パン（枠専用pane） ---
    const framePane = map.createPane('frame-pane');
    framePane.classList.add('frame-pane');

    // --- オーバーレイ ---
    const overlay = {
      points: L.layerGroup().addTo(map),
      lines: L.layerGroup().addTo(map),
      labels: L.layerGroup(),
      frame: L.layerGroup({ pane: 'frame-pane' }).addTo(map)
    };

    // --- GeoJSON読込 ---
    Promise.all([
      fetch('points.geojson').then(r => r.ok ? r.json() : null),
      fetch('lines.geojson').then(r => r.ok ? r.json() : null),
      fetch('labels.geojson').then(r => r.ok ? r.json() : null),
      fetch('frame.geojson').then(r => r.ok ? r.json() : null)
    ]).then(([points, lines, labels, frame]) => {
      if (points) {
        L.geoJSON(points, {
          pointToLayer: (f, latlng) => L.circleMarker(latlng, {
            radius: 8, weight: 2, color: '#333', fillColor: '#4db', fillOpacity: 0.9
          }),
          onEachFeature: (f, layer) => {
            const p = f.properties || {};
            const name = p.name || '地点';
            const url = p.url;
            let html = `<strong>${name}</strong>`;
            if (url) html += `<br><a href="${url}" target="_blank" rel="noopener">開く</a>`;
            layer.bindPopup(html, { maxWidth: 260 });
          }
        }).addTo(overlay.points);
      }

      if (lines) {
        L.geoJSON(lines, {
          style: f => ({ color: '#1e88e5', weight: 3, opacity: 0.9, fillOpacity: 0.05 })
        }).addTo(overlay.lines);
      }

      if (labels) {
        L.geoJSON(labels, {
          pointToLayer: (f, latlng) => L.marker(latlng, { interactive: false }),
          onEachFeature: (f, layer) => {
            const name = (f.properties && f.properties.name) || '';
            if (name) layer.bindTooltip(name, { permanent: true, direction: 'center', className: 'lbl' });
          }
        }).addTo(overlay.labels);
      }

      if (frame) {
        L.geoJSON(frame, {
          pane: 'frame-pane',
          interactive: false,
          style: f => ({ color: '#000', weight: 2, opacity: 1, fill: false })
        }).addTo(overlay.frame);
      }

      const all = L.featureGroup([overlay.points, overlay.lines, overlay.labels, overlay.frame]);
      try { map.fitBounds(all.getBounds(), { padding: [20, 20] }); } catch (_) {}
    });

    // --- レイヤーパネル操作 ---
    document.getElementById('layerPanel').addEventListener('change', (e) => {
      const t = e.target;
      if (t.name === 'base') {
        Object.entries(baseLayers).forEach(([key, tl]) => {
          if (key === t.value) {
            if (!map.hasLayer(tl)) tl.addTo(map);
          } else {
            if (map.hasLayer(tl)) map.removeLayer(tl);
          }
        });
      }
      if (t.dataset.overlay) {
        const key = t.dataset.overlay;
        if (t.checked) overlay[key].addTo(map);
        else map.removeLayer(overlay[key]);
      }
    });
  </script>
</body>
</html>